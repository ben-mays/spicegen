// Code generated by spicegen. DO NOT EDIT
package authz

import (
	"context"
	"errors"
	"fmt"
	"sync"

	pb "github.com/authzed/authzed-go/proto/authzed/api/v1"
	structpb "google.golang.org/protobuf/types/known/structpb"

	"github.com/ben-mays/spicegen/examples/permissions/document"

	"github.com/ben-mays/spicegen/examples/permissions/organization"
)

// SpicedbClient is the interface that the spicegen generated client invokes. It exists to allow support for both GRPC and HTTP clients. A helper function NewAuthzedClient is provided to wrap
// the typical GRPC client.
type SpicedbClient interface {
	CheckPermission(ctx context.Context, subject Resource, permission string, resource Resource, opts *CheckPermissionOptions) (bool, error)
	AddRelation(ctx context.Context, resource Resource, relation string, subject Resource, opts *AddRelationOptions) (string, error)
	RemoveRelation(ctx context.Context, resource Resource, relation string, subject Resource, opts *RemoveRelationOptions) (string, error)
}

type CheckPermissionOptions struct {
	Context     *structpb.Struct
	Consistency *pb.Consistency
}

type AddRelationOptions struct {
	Caveat           *pb.ContextualizedCaveat
	OptionalRelation string
}

type RemoveRelationOptions struct{}

type AuthzedClient interface {
	pb.PermissionsServiceClient
	pb.SchemaServiceClient
}

type authzedClient struct {
	client AuthzedClient
}

// Wraps a authzed.Client instance in the SpicedbClient interface
func NewAuthzedClient(client AuthzedClient) SpicedbClient {
	return &authzedClient{client}
}

func (c *authzedClient) CheckPermission(ctx context.Context, subject Resource, permission string, resource Resource, opts *CheckPermissionOptions) (bool, error) {
	var consistency *pb.Consistency
	var context *structpb.Struct
	if opts != nil {
		consistency = opts.Consistency
		context = opts.Context
	}
	resp, err := c.client.CheckPermission(ctx, &pb.CheckPermissionRequest{
		Consistency: consistency,
		Context:     context,
		Subject: &pb.SubjectReference{
			Object: &pb.ObjectReference{ObjectType: string(subject.ResourceType()), ObjectId: subject.ID()},
		},
		Permission: permission,
		Resource:   &pb.ObjectReference{ObjectType: string(resource.ResourceType()), ObjectId: resource.ID()},
	})
	if err != nil {
		return false, err
	}
	return resp.Permissionship == pb.CheckPermissionResponse_PERMISSIONSHIP_HAS_PERMISSION, nil
}

func (c *authzedClient) AddRelation(ctx context.Context, resource Resource, relation string, subject Resource, opts *AddRelationOptions) (string, error) {
	var caveat *pb.ContextualizedCaveat
	if opts != nil {
		caveat = opts.Caveat
	}
	resp, err := c.client.WriteRelationships(ctx, &pb.WriteRelationshipsRequest{
		Updates: []*pb.RelationshipUpdate{{
			Operation: pb.RelationshipUpdate_OPERATION_TOUCH,
			Relationship: &pb.Relationship{
				Subject: &pb.SubjectReference{
					Object: &pb.ObjectReference{
						ObjectType: string(subject.ResourceType()),
						ObjectId:   subject.ID(),
					},
					OptionalRelation: opts.OptionalRelation,
				},
				Relation: relation,
				Resource: &pb.ObjectReference{
					ObjectType: string(resource.ResourceType()),
					ObjectId:   resource.ID(),
				},
				OptionalCaveat: caveat,
			},
		}},
	})
	if err != nil {
		return "", err
	}
	return resp.WrittenAt.Token, nil
}

func (c *authzedClient) RemoveRelation(ctx context.Context, resource Resource, relation string, subject Resource, opts *RemoveRelationOptions) (string, error) {
	resp, err := c.client.DeleteRelationships(ctx, &pb.DeleteRelationshipsRequest{
		RelationshipFilter: &pb.RelationshipFilter{ResourceType: string(resource.ResourceType()), OptionalResourceId: resource.ID(), OptionalRelation: relation, OptionalSubjectFilter: &pb.SubjectFilter{SubjectType: string(subject.ResourceType()), OptionalSubjectId: subject.ID()}},
	})
	if err != nil {
		return "", err
	}
	return resp.DeletedAt.Token, nil
}

// Client is a SpiceDB client that can be used to check permissions on resources. It is safe for concurrent use.
type Client struct {
	sync.RWMutex

	spicedbClient SpicedbClient
	// Lock protects lastZedToken. Updated whenever a write occurs to provide read-my-write semantics.
	lastZedToken string
}

func NewClient(spicedbClient SpicedbClient) *Client {
	return &Client{
		spicedbClient: spicedbClient,
	}
}

func (c *Client) getConsistency() *pb.Consistency {
	return &pb.Consistency{Requirement: &pb.Consistency_AtLeastAsFresh{AtLeastAsFresh: &pb.ZedToken{Token: c.lastZedToken}}}
}

func (c *Client) CheckPermission(ctx context.Context, subject Resource, permission string, resource Resource, opts *CheckPermissionOptions) (bool, error) {
	c.RLock()
	defer c.RUnlock()
	if opts == nil {
		opts = &CheckPermissionOptions{}
	}
	if opts.Consistency == nil {
		if c.lastZedToken != "" {
			opts.Consistency = c.getConsistency()
		}
	}
	return c.spicedbClient.CheckPermission(ctx, subject, permission, resource, opts)
}

func (c *Client) CheckDocumentPermission(ctx context.Context, resource DocumentResource, permission document.DocumentPermission, subject Resource, opts *CheckPermissionOptions) (bool, error) {
	if document.ALLOWED_PERMISSION_SUBJECT_TYPES[permission][string(subject.ResourceType())] || document.ALLOWED_PERMISSION_SUBJECT_TYPES[permission]["*"] {
		return c.CheckPermission(ctx, subject, string(permission), resource, opts)
	} else {
		return false, errors.New(fmt.Sprintf("subject type not allowed for permission %s", string(permission)))
	}
}

func (c *Client) CheckOrganizationPermission(ctx context.Context, resource OrganizationResource, permission organization.OrganizationPermission, subject UserResource, opts *CheckPermissionOptions) (bool, error) {
	if organization.ALLOWED_PERMISSION_SUBJECT_TYPES[permission][string(subject.ResourceType())] || organization.ALLOWED_PERMISSION_SUBJECT_TYPES[permission]["*"] {
		return c.CheckPermission(ctx, subject, string(permission), resource, opts)
	} else {
		return false, errors.New(fmt.Sprintf("subject type not allowed for permission %s", string(permission)))
	}
}

func (c *Client) AddRelation(ctx context.Context, resource Resource, relation string, subject Resource, opts *AddRelationOptions) error {
	c.Lock()
	defer c.Unlock()
	token, err := c.spicedbClient.AddRelation(ctx, resource, relation, subject, opts)
	if err != nil {
		return err
	}
	c.lastZedToken = token
	return nil
}

func (c *Client) AddDocumentRelation(ctx context.Context, resource DocumentResource, relation document.DocumentRelation, subject Resource, opts *AddRelationOptions) error {
	if document.ALLOWED_RELATION_SUBJECT_TYPES[relation][string(subject.ResourceType())] || document.ALLOWED_RELATION_SUBJECT_TYPES[relation]["*"] {
		return c.AddRelation(ctx, resource, string(relation), subject, opts)
	} else {
		return errors.New(fmt.Sprintf("subject type not allowed for relation %s", string(relation)))
	}
}

func (c *Client) AddOrganizationRelation(ctx context.Context, resource OrganizationResource, relation organization.OrganizationRelation, subject UserResource, opts *AddRelationOptions) error {
	if organization.ALLOWED_RELATION_SUBJECT_TYPES[relation][string(subject.ResourceType())] || organization.ALLOWED_RELATION_SUBJECT_TYPES[relation]["*"] {
		return c.AddRelation(ctx, resource, string(relation), subject, opts)
	} else {
		return errors.New(fmt.Sprintf("subject type not allowed for relation %s", string(relation)))
	}
}

func (c *Client) RemoveRelation(ctx context.Context, resource Resource, relation string, subject Resource, opts *RemoveRelationOptions) error {
	c.Lock()
	defer c.Unlock()
	token, err := c.spicedbClient.RemoveRelation(ctx, resource, relation, subject, opts)
	if err != nil {
		return err
	}
	c.lastZedToken = token
	return nil
}

func (c *Client) RemoveDocumentRelation(ctx context.Context, resource DocumentResource, relation document.DocumentRelation, subject Resource, opts *RemoveRelationOptions) error {
	return c.RemoveRelation(ctx, resource, string(relation), subject, opts)
}

func (c *Client) RemoveOrganizationRelation(ctx context.Context, resource OrganizationResource, relation organization.OrganizationRelation, subject UserResource, opts *RemoveRelationOptions) error {
	return c.RemoveRelation(ctx, resource, string(relation), subject, opts)
}
