// Code generated by spicegen. DO NOT EDIT
package {{.PackageName}}

import (
	"sync"
	"context"
	"errors"
	"fmt"

	pb "github.com/authzed/authzed-go/proto/authzed/api/v1"
	spicedb "github.com/authzed/authzed-go/v1"
	structpb "google.golang.org/protobuf/types/known/structpb"


	{{ $import := .ImportPath }}
	{{ range $rsc := .Resources }}{{ if $rsc.Relations }}"{{ $import }}/permissions/{{ $rsc.Name }}"{{end}}
	{{end}}
)

{{/* Create a ResourceType for each resource */}}
type ResourceType string
const (
{{ range $rsc := .Resources }}{{ $rsc.Name | ToCamel }} ResourceType = "{{ $rsc.Name }}"
{{ end }}
)

type Resource interface {
	ResourceType() ResourceType
	ID() string
}

{{/* For each resource type, create a concrete struct */}}
{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
type {{ $resource }}Resource struct {
	rid string
}

func (r {{ $resource }}Resource) ID() string {
	return r.rid
}

func (r {{ $resource }}Resource) ResourceType() ResourceType {
	return {{ $resource }}
}

func New{{ $resource }}Resource(ID string) {{ $resource }}Resource {
	return {{ $resource }}Resource{rid: ID}
}
{{end}}

// Client is a SpiceDB client that can be used to check permissions on resources. It is safe for concurrent use.
type Client struct {
	sync.RWMutex

	spicedbClient *spicedb.Client
	// Lock protects lastZedToken from 
	lastZedToken string
}

func NewClient(spicedbClient *spicedb.Client) *Client { 
	return &Client{
		spicedbClient: spicedbClient,
	} 
}

type CheckPermissionOptions struct {
	Context *structpb.Struct
	Consistency *pb.Consistency
}

func (c *Client) getConsistency() *pb.Consistency {
	return &pb.Consistency{Requirement: &pb.Consistency_AtLeastAsFresh{AtLeastAsFresh: &pb.ZedToken{Token: c.lastZedToken}}}
}

func (c *Client) CheckPermission(ctx context.Context, subject Resource, permission string, resource Resource, opts *CheckPermissionOptions) (bool, error) {
	c.RLock()
	defer c.RUnlock()
	var consistency *pb.Consistency
	var context *structpb.Struct
	if opts != nil {
		consistency = opts.Consistency
		context = opts.Context
	}
	if consistency == nil {
		if c.lastZedToken != "" {
			consistency = c.getConsistency()
		}
	}
	resp, err := c.spicedbClient.CheckPermission(ctx, &pb.CheckPermissionRequest{
		Consistency: consistency,
		Context: context,
		Subject: &pb.SubjectReference{
			Object: &pb.ObjectReference{ObjectType: string(subject.ResourceType()), ObjectId: subject.ID()},
		},
		Permission: permission,
		Resource:   &pb.ObjectReference{ObjectType: string(resource.ResourceType()), ObjectId: resource.ID()},
	})
	if err != nil {
		return false, err
	}
	c.lastZedToken = resp.CheckedAt.Token
	return resp.Permissionship == pb.CheckPermissionResponse_PERMISSIONSHIP_HAS_PERMISSION, nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Permissions }}
{{ $subjectType := $rsc.PermissionSubjectType | ToCamel }} 
func (c *Client) Check{{ $resource }}Permission(ctx context.Context, resource {{ $resource }}Resource, permission {{ $rsc.Name }}.{{ $resource }}Permission, subject {{ $subjectType }}, opts *CheckPermissionOptions) (bool, error) {
	if {{ $rsc.Name }}.ALLOWED_PERMISSION_SUBJECT_TYPES[permission][string(subject.ResourceType())] || {{ $rsc.Name }}.ALLOWED_PERMISSION_SUBJECT_TYPES[permission]["*"] {
		return c.CheckPermission(ctx, subject, string(permission), resource, opts)
	} else {
		return false, errors.New(fmt.Sprintf("subject type not allowed for permission %s", string(permission)))
	}
} {{ end }}
{{ end}}

type AddRelationshipOptions struct {
	Caveat *pb.ContextualizedCaveat
}

func (c *Client) AddRelationship(ctx context.Context, resource Resource, relation string, subject Resource, opts *AddRelationshipOptions) (bool, error) {
	c.Lock()
	defer c.Unlock()
	var caveat *pb.ContextualizedCaveat
	if opts != nil {
		caveat = opts.Caveat
	}
	resp, err := c.spicedbClient.WriteRelationships(ctx, &pb.WriteRelationshipsRequest{
		Updates: []*pb.RelationshipUpdate{ {
			Operation: pb.RelationshipUpdate_OPERATION_TOUCH,
			Relationship: &pb.Relationship{
				Subject: &pb.SubjectReference{
					Object: &pb.ObjectReference{
						ObjectType: string(subject.ResourceType()),
						ObjectId:   subject.ID(),
					},
				},
				Relation: relation,
				Resource: &pb.ObjectReference{
					ObjectType: string(resource.ResourceType()),
					ObjectId:   resource.ID(),
				},
				OptionalCaveat: caveat,
			},
		} },
	})
	if err != nil {
		return false, err
	}
	c.lastZedToken = resp.WrittenAt.Token
	return true, nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Relations }}
{{ $subjectType := $rsc.RelationSubjectType | ToCamel }}
func (c *Client) Add{{ $resource }}Relationship(ctx context.Context, resource {{ $resource }}Resource, relation {{ $rsc.Name }}.{{ $resource }}Relation, subject {{ $subjectType }}, opts *AddRelationshipOptions) (bool, error) {
	if {{ $rsc.Name }}.ALLOWED_RELATION_SUBJECT_TYPES[relation][string(subject.ResourceType())] || {{ $rsc.Name }}.ALLOWED_RELATION_SUBJECT_TYPES[relation]["*"] {
		return c.AddRelationship(ctx, resource, string(relation), subject, opts)
	} else {
		return false, errors.New(fmt.Sprintf("subject type not allowed for relation %s", string(relation)))
	}
} {{ end }}
{{ end}}

func (c *Client) DeleteRelationship(ctx context.Context, resource Resource, relation string, subject Resource) (bool, error) {
	c.Lock()
	defer c.Unlock()
	resp, err := c.spicedbClient.DeleteRelationships(ctx, &pb.DeleteRelationshipsRequest{
		RelationshipFilter: &pb.RelationshipFilter{ResourceType: string(resource.ResourceType()), OptionalResourceId: resource.ID(), OptionalRelation: relation, OptionalSubjectFilter: &pb.SubjectFilter{SubjectType: string(subject.ResourceType()), OptionalSubjectId: subject.ID()}},
	})
	if err != nil {
		return false, err
	}
	c.lastZedToken = resp.DeletedAt.Token
	return true, nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Relations }} 
{{ $subjectType := $rsc.RelationSubjectType | ToCamel }}
func (c *Client) Delete{{ $resource }}Relationship(ctx context.Context, resource {{ $resource }}Resource, relation {{ $rsc.Name }}.{{ $resource }}Relation, subject {{ $subjectType }}) (bool, error) {
	return c.DeleteRelationship(ctx, resource, string(relation), subject)
} {{ end }}
{{ end}}
