// Code generated by spicegen. DO NOT EDIT
package {{.PackageName}}

import (
	"sync"
	"context"
	"fmt"
	"io"

	pb "github.com/authzed/authzed-go/proto/authzed/api/v1"
	structpb "google.golang.org/protobuf/types/known/structpb"


	{{ $import := .ImportPath }}
	{{ range $rsc := .Resources }}{{ if $rsc.Relations }}"{{ $import }}/permissions/{{ $rsc.Name }}"{{end}}
	{{end}}
)
{{$ClientName := .ClientName}}
{{$InterfaceName := .InterfaceName}}
// SpiceDBClient is the interface that the spicegen generated client wraps.
type SpiceDBClient interface {
	pb.PermissionsServiceClient
	pb.SchemaServiceClient
}


// {{.ClientName}} is a SpiceDB client that can be used to check permissions on resources. It is safe for concurrent use. This client implements {{.InterfaceName}}.
type {{.ClientName}} struct {
	sync.RWMutex

	spicedbClient SpiceDBClient
	// Lock protects lastZedToken. Updated whenever a write occurs to provide read-my-write semantics. 
	lastZedToken string
}

func New{{.ClientName}}(spicedbClient SpiceDBClient) {{.InterfaceName}} { 
	return &{{.ClientName}}{
		spicedbClient: spicedbClient,
	} 
}

// must be taken within a lock
func (c *{{.ClientName}}) getConsistency() *pb.Consistency {
	if c.lastZedToken == "" {
		return &pb.Consistency{Requirement: &pb.Consistency_FullyConsistent{FullyConsistent: true}}
	}
	return &pb.Consistency{Requirement: &pb.Consistency_AtLeastAsFresh{AtLeastAsFresh: &pb.ZedToken{Token: c.lastZedToken}}}
}

func (c *{{.ClientName}}) CheckPermission(ctx context.Context, subject Resource, permission string, resource Resource, opts *CheckPermissionOptions) (bool, error) {
	c.RLock()
	defer c.RUnlock()
	var context *structpb.Struct
	if opts != nil {
		context = opts.Context
	}
	resp, err := c.spicedbClient.CheckPermission(ctx, &pb.CheckPermissionRequest{
		Consistency: c.getConsistency(),
		Context: context,
		Subject: &pb.SubjectReference{
			Object: &pb.ObjectReference{ObjectType: string(subject.ResourceType()), ObjectId: subject.ID()},
		},
		Permission: permission,
		Resource:   &pb.ObjectReference{ObjectType: string(resource.ResourceType()), ObjectId: resource.ID()},
	})
	if err != nil {
		return false, err
	}
	return resp.Permissionship == pb.CheckPermissionResponse_PERMISSIONSHIP_HAS_PERMISSION, nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Permissions }}
{{ $subjectType := $rsc.PermissionSubjectType | ToCamel }} 
func (c *{{$ClientName}}) Check{{ $resource }}Permission(ctx context.Context, subject {{ $subjectType }}, permission {{ $rsc.Name }}.{{ $resource }}Permission, resource {{ $resource }}Resource, opts *CheckPermissionOptions) (bool, error) {
	if {{ $rsc.Name }}.ALLOWED_PERMISSION_SUBJECT_TYPES[permission][string(subject.ResourceType())] || {{ $rsc.Name }}.ALLOWED_PERMISSION_SUBJECT_TYPES[permission]["*"] {
		return c.CheckPermission(ctx, subject, string(permission), resource, opts)
	} else {
		return false, fmt.Errorf("subject type not allowed for permission %s", string(permission))
	}
} {{ end }}
{{ end}}

func (c *{{$ClientName}}) AddRelationship(ctx context.Context, resource Resource, relation string, subject Resource, opts *AddRelationshipOptions) (error) {
	c.Lock()
	defer c.Unlock()
	var caveat *pb.ContextualizedCaveat
	if opts != nil {
		caveat = opts.Caveat
	}
	subjectRef := &pb.SubjectReference{
		Object: &pb.ObjectReference{
			ObjectType: string(subject.ResourceType()),
			ObjectId:   subject.ID(),
		},
	}
	if opts != nil && opts.OptionalSubjectRelation != "" {
		subjectRef.OptionalRelation = opts.OptionalSubjectRelation
	}
	resp, err := c.spicedbClient.WriteRelationships(ctx, &pb.WriteRelationshipsRequest{
		Updates: []*pb.RelationshipUpdate{ {
			Operation: pb.RelationshipUpdate_OPERATION_TOUCH,
			Relationship: &pb.Relationship{
				Subject: subjectRef,
				Relation: relation,
				Resource: &pb.ObjectReference{
					ObjectType: string(resource.ResourceType()),
					ObjectId:   resource.ID(),
				},
				OptionalCaveat: caveat,
			},
		} },
	})
	if err != nil {
		return err
	}
	c.lastZedToken = resp.WrittenAt.Token
	return nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Relations }}
{{ $subjectType := $rsc.RelationSubjectType | ToCamel }}
func (c *{{$ClientName}}) Add{{ $resource }}Relationship(ctx context.Context, resource {{ $resource }}Resource, relation {{ $rsc.Name }}.{{ $resource }}Relation, subject {{ $subjectType }}, opts *AddRelationshipOptions) (error) {
	optionalRelation, allowed := {{ $rsc.Name }}.ALLOWED_RELATION_SUBJECT_TYPES[relation][string(subject.ResourceType())]
	_, hasWildcard := {{ $rsc.Name }}.ALLOWED_RELATION_SUBJECT_TYPES[relation]["*"]
	if allowed && optionalRelation != "..." && (opts == nil || opts.OptionalSubjectRelation != optionalRelation) {
		return fmt.Errorf("relation `%s` requires an optional subject relation `%s` for subject type `%s`", string(relation), optionalRelation, subject.ResourceType())
	}
	if allowed || hasWildcard {
		return c.AddRelationship(ctx, resource, string(relation), subject, opts)
	} else {
		return fmt.Errorf("subject type not allowed for relation %s", string(relation))
	}
} {{ end }}
{{ end}}


func (c *{{$ClientName}}) DeleteRelationship(ctx context.Context, resource Resource, relation string, subject Resource, opts *DeleteRelationshipOptions) (error) {
	c.Lock()
	defer c.Unlock()
	subjectFilter := &pb.SubjectFilter{SubjectType: string(subject.ResourceType()), OptionalSubjectId: subject.ID()}
	if opts != nil && opts.OptionalSubjectRelation != "" {
		subjectFilter.OptionalRelation = &pb.SubjectFilter_RelationFilter{Relation: opts.OptionalSubjectRelation}
	}
	resp, err := c.spicedbClient.DeleteRelationships(ctx, &pb.DeleteRelationshipsRequest{
		RelationshipFilter: &pb.RelationshipFilter{ResourceType: string(resource.ResourceType()), OptionalResourceId: resource.ID(), OptionalRelation: relation, OptionalSubjectFilter: subjectFilter},
	})
	if err != nil {
		return err
	}
	c.lastZedToken = resp.DeletedAt.Token
	return nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Relations }} 
{{ $subjectType := $rsc.RelationSubjectType | ToCamel }}
func (c *{{$ClientName}}) Delete{{ $resource }}Relationship(ctx context.Context, resource {{ $resource }}Resource, relation {{ $rsc.Name }}.{{ $resource }}Relation, subject {{ $subjectType }}, opts *DeleteRelationshipOptions) (error) {
	return c.DeleteRelationship(ctx, resource, string(relation), subject, opts)
} {{ end }}
{{ end}}

func (c *{{$ClientName}}) LookupResources(ctx context.Context, resourceType ResourceType, subject Resource, permission string, opts *LookupResourcesOptions) ([]Resource, string, error) {
	c.RLock()
	defer c.RUnlock()
	subjectRef := &pb.SubjectReference{
		Object: &pb.ObjectReference{
			ObjectType: string(subject.ResourceType()),
			ObjectId:   subject.ID(),
		},
	}
	if opts != nil && opts.OptionalSubjectRelation != "" {
		subjectRef.OptionalRelation = opts.OptionalSubjectRelation
	}
	req := &pb.LookupResourcesRequest{
		Consistency:        c.getConsistency(),
		ResourceObjectType: string(resourceType),
		Subject: subjectRef,
		Permission: permission,
	}
	if opts != nil && opts.Pagination.Limit != 0 {
		req.OptionalLimit = uint32(opts.Pagination.Limit)
	}
	if opts != nil && opts.Pagination.Token != "" {
		req.OptionalCursor = &pb.Cursor{Token: opts.Pagination.Token}
	}
	client, err := c.spicedbClient.LookupResources(ctx, &pb.LookupResourcesRequest{
		Consistency: c.getConsistency(),
		ResourceObjectType: string(resourceType),
		Permission: permission,
		Subject: subjectRef,
	})
	if err != nil {
		return nil, "", err
	}
	resources := make([]Resource, 0)
	lastToken := ""
	for {
		resp, err := client.Recv()
		if resp != nil && resp.ResourceObjectId != "" {
			// suppress error because we _know_ this is a correct resource type given the generation
			resource, _ := NewResource(resourceType, resp.ResourceObjectId)
			resources = append(resources, resource)
			if resp.AfterResultCursor != nil {
				lastToken = resp.AfterResultCursor.Token
			}
		}
		if err != nil {
			if err == io.EOF {
				break
			} else {
				return nil, "", err
			}
		}
	}
	return resources, lastToken, nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Permissions }} 
{{ $subjectType := $rsc.PermissionSubjectType | ToCamel }}
func (c *{{$ClientName}}) Lookup{{ $resource }}Resources(ctx context.Context, subject {{ $subjectType }}, permission {{ $rsc.Name }}.{{ $resource }}Permission, opts *LookupResourcesOptions)  ([]Resource, string, error) {
	return c.LookupResources(ctx, {{ $resource }}, subject, string(permission), opts)
} {{ end }}
{{ end}}

func (c *{{$ClientName}}) LookupSubjects(ctx context.Context, resource Resource, subjectType ResourceType, permission string, opts *LookupSubjectsOptions) ([]Resource, string, error) {
	c.RLock()
	defer c.RUnlock()
	req := &pb.LookupSubjectsRequest{
		Consistency:             c.getConsistency(),
		Resource:                &pb.ObjectReference{ObjectType: string(resource.ResourceType()), ObjectId: resource.ID()},
		SubjectObjectType:       string(subjectType),
		OptionalSubjectRelation: opts.OptionalSubjectRelation,
		Permission:              permission,
	}
	if opts != nil && opts.Pagination.Limit != 0 {
		req.OptionalConcreteLimit = uint32(opts.Pagination.Limit)
	}
	if opts != nil && opts.Pagination.Token != "" {
		req.OptionalCursor = &pb.Cursor{Token: opts.Pagination.Token}
	}
	client, err := c.spicedbClient.LookupSubjects(ctx, req)
	if err != nil {
		return nil, "", err
	}
	subjects := make([]Resource, 0)
	lastToken := ""
	for {
		resp, err := client.Recv()
		if resp != nil && resp.Subject != nil {
			subject, _ := NewResource(subjectType, resp.Subject.SubjectObjectId)
			subjects = append(subjects, subject)
			if resp.AfterResultCursor != nil {
				lastToken = resp.AfterResultCursor.Token
			}
		}
		if err != nil {
			if err == io.EOF {
				break
			} else {
				return nil, "", err
			}
		}
	}
	return subjects, lastToken, nil
}

{{ range $rsc := .Resources }}{{ $resource := $rsc.Name | ToCamel }}
{{ if $rsc.Permissions }} 
{{ $subjectType := $rsc.PermissionSubjectType | ToCamel }}
func (c *{{$ClientName}}) Lookup{{ $resource }}Subjects(ctx context.Context, resourceID string, subjectType ResourceType, permission {{ $rsc.Name }}.{{ $resource }}Permission, opts *LookupSubjectsOptions)  ([]Resource, string, error) {
	resource, _ := NewResource({{$resource}}, resourceID)
	return c.LookupSubjects(ctx, resource, subjectType, string(permission), opts)
} {{ end }}
{{ end}}
